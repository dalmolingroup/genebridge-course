---
title: "Gene Rooting"
author: "Dalmolin Systems Biology Group"
format: html
execute: 
  cache: true
---

```{r setup1, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  results = FALSE
)
```

## Importing libraries

```{r}
library(GeneBridge)
library(geneplast.data)
library(readr)
library(dplyr)
library(purrr)
library(biomaRt)
library(magrittr)
library(KEGGREST)
library(ape)
library(tidyverse)
library(data.table)
library(stringi)
library(AnnotationHub)
library(sourcetools)
library(here)
```

## Defining functions for later use

`get_string_ids` searches for the respective protein ID for each gene in the input list.\n `get_network_interaction` returns the interactions between these proteins. \n `combine_scores` filters the interactions by a combined confidence score greater than 0.4.

```{r}
# get IDs from STRING DB
get_string_ids <- function(genes_hgnc, species_id = "9606") {

    req <- RCurl::postForm(
    "https://string-db.org/api/tsv/get_string_ids",
    identifiers = paste(genes_hgnc, collapse = "%0D"),  
    echo_query = "1",
    species = species_id, 
    .opts = list(ssl.verifypeer = FALSE)
  )
  
  map_ids <- read.table(text = req, sep = "\t", header = TRUE, quote = "") %>%
    dplyr::select(-queryIndex) %>%
    unique()
  
  map_ids$stringId <- substring(map_ids$stringId, 6, 1000)
  
  return(map_ids)
}

 # Get STRING interactions
 get_network_interaction <- function(map_ids, protein_id, species_id = "9606") {
 
   identifiers <- map_ids %>% pull(protein_id) %>% na.omit %>% paste0(collapse="%0d") 
 
   req2 <- RCurl::postForm(
     "https://string-db.org/api/tsv/network",
     identifiers = identifiers, 
     required_core = "0", 
     species = species_id,
     .opts = list(ssl.verifypeer = FALSE)
   )
   
   int_network <- read.table(text = req2, sep = "\t", header = TRUE)
   
   int_network <- unique(int_network)
   
   return(int_network)
 }

 ## Recomputing scores
combine_scores <- function(dat, evidences = "all", confLevel = 0.4) {
  if(evidences[1] == "all"){
    edat<-dat[,-c(1,2,ncol(dat))]
  } else {
    if(!all(evidences%in%colnames(dat))){
      stop("NOTE: one or more 'evidences' not listed in 'dat' colnames!")
    }
    edat<-dat[,evidences]
  }
  if (any(edat > 1)) {
    edat <- edat/1000
  }
  edat<-1-edat
  sc<- apply(X = edat, MARGIN = 1, FUN = function(x) 1-prod(x))
  dat <- cbind(dat[,c(1,2)],combined_score = sc)
  idx <- dat$combined_score >= confLevel
  dat <-dat[idx,]
  return(dat)
}
```

## Loading gene list and orthology data

We load the orthology data using [AnnotationHub](https://www.bioconductor.org/packages/devel/bioc/html/AnnotationHub.html). This R package provides a central location where genomic files (VCF, bed, wig) and other resources from standard locations (e.g., UCSC, Ensembl) can be accessed. This way, we have access to the input files for the GeneBridge algorithm.

```{r}
# Load the Gene Set Table
sensorial_genes <- read.csv("../data/sensorial_genes.csv")

# Query Phylotree and OG data
ah <- AnnotationHub()
meta <- query(ah, "geneplast")
load(meta[["AH83116"]])

head(sensorial_genes)
head(cogdata)
```

## Pre-processing

### Mapping

For the following analyses, we need to cross-reference information between our genes of interest (Gene IDs from the `sensorial_genes` table) and Protein IDs (from the `cogdata` table). The STRINGdb API is used to map the Gene IDs to the Protein IDs, which allows for filtering the genes of interest in the `cogdata` table. The final goal is to obtain a filtered set of sensory genes with their respective pathways and COG IDs.

```{r }
map_ids <- get_string_ids(sensorial_genes$gene_symbol)

# Subsetting cogs of interest - Sensorial Genes
gene_cogs <- cogdata %>%
  filter(ssp_id %in% map_ids$ncbiTaxonId) %>%
  filter(protein_id %in% map_ids[["stringId"]]) %>%
  group_by(protein_id) %>%
  summarise(n = n(), cog_id = paste(cog_id, collapse = " / "))

head(map_ids)

#map_ids |> 
#  vroom::vroom_write(file = here("data/map_ids.csv"), delim = ",")
```

### Resolving Duplicate COGs

Due to evolutionary events, such as gene duplication, some genes may be associated with more than one Cluster of Orthologous Groups (COG). To ensure the algorithm's functionality, it is necessary to resolve these cases by prioritizing COGs according to the following criteria:

1.  Priority by COG Type: This hierarchy ensures the most functionally relevant annotation is chosen first.

-   **KOGs (euKaryotic Orthologous Groups):** have the highest priority. This database is specifically curated for eukaryotes, providing the most contextually accurate annotation.

-   **COGs (Clusters of Orthologous Groups):** have the next priority. Originally focused on prokaryotes.

-   **NOGs (from the eggNOG database):** are used as the fallback. This is the most comprehensive and general database, covering all domains of life, and is used when a more specific classification isn't available.

2.  Cases with COGs from the same database:

-   These are resolved manually, based on the annotated function of the COG and the scientific question of the study.

The code below implements this resolution and integrates the corrections into the main table.

```{r}
gene_cogs %>% filter(n > 1)

# Resolving main proteins
gene_cogs_resolved <- tribble(
  ~protein_id, ~cog_id,
"ENSP00000332500", "NOG274749", #NOG274749 / NOG274749		
"ENSP00000409316", "NOG282909", #NOG282909 / NOG282909 / NOG282909		
"ENSP00000480090", "KOG3599"	  #KOG3599 / KOG3272
)

# Removing unresolved cases and adding manual assignments
gene_cogs %<>%
  filter(n == 1) %>%
 dplyr:: select(-n) %>%
  bind_rows(gene_cogs_resolved)

#gene_cogs |> 
#  vroom::vroom_write(file = here("data/gene_cogs.csv"), delim = ",")
```

## Processing

The objective of this step is to perform the rooting of the genes of interest using the **GeneBridge** package. To do this, we use the `newBridge`, `runBridge`, and `runPermutation` functions, which produce statistical results associated with the selected COGs in a phylogenetic tree.

### Required Inputs

1.  **`ogdata`**:
    -   A dataset containing three main columns:
        -   `Protein ID`: Identifiers for the proteins.
        -   `COG ID`: Clusters of interest.
        -   `Specie ID`: Identifiers for the species.
    -   In this example, the `cogdata` object is being used.
2.  **`phyloTree`**:
    -   A phylogenetic tree containing 476 eukaryotes, representing the evolutionary structure among the analyzed species.
3.  **`ogids`**:
    -   A list of the **COGs of interest**. This set is derived from the `gene_cogs` table and includes the COGs associated with the proteins after the previous processing step.
4.  **`refsp`**:
    -   The reference species for rooting. In this example, we use `9606` (human).

The *getBridge* function extracts the results generated by GeneBridge in a table format. The *res* table contains the statistical results of the rooting.

```{r}
## Run GeneBridge
cogs_of_interest <- gene_cogs %>% pull(cog_id) %>% unique

ogr <- newBridge(ogdata=cogdata, phyloTree=phyloTree, ogids = cogs_of_interest, refsp="9606")

ogr <- runBridge(ogr, penalty = 2, threshold = 0.5, verbose = TRUE)

ogr <- runPermutation(ogr, nPermutations=1000, verbose=FALSE)

res <- getBridge(ogr, what="results")

#saveRDS(ogr, file = "../data/ogr.RData")
```

## Post-Processing

After performing the rooting with **GeneBridge**, the data needs to be adjusted to improve the visualization and interpretation of the results. In this step, we add clade names to the identified roots by using an external table that maps the root identifiers to their corresponding clade names.

```{r}
# naming the rooted clades
CLADE_NAMES <- "https://raw.githubusercontent.com/dalmolingroup/neurotransmissionevolution/ctenophora_before_porifera/analysis/geneplast_clade_names.tsv"

lca_names <- vroom::vroom(CLADE_NAMES)

groot_df <- res %>%
  tibble::rownames_to_column("cog_id") %>%
  dplyr::select(cog_id, root = Root) %>%
  left_join(lca_names) %>%
  inner_join(gene_cogs)

head(groot_df)

#groot_df |> 
#  vroom::vroom_write(file = here("data/groot_df.csv"), delim = ",")
```

### Protein-Protein Interaction Network

To build a protein-protein interaction (PPI) network we use the **STRINGdb** API, a database that catalogs interactions between proteins based on various sources, including experimental assays, co-expression, and evidence extracted from scientific publications.

The STRINGdb API provides methods to:
- Obtain protein interactions for a list of proteins.
- Select specific sources of evidence.
- Calculate and combine scores based on the selected evidence.

More information about the API can be found in the [STRING API documentation](https://string-db.org/help/api/).

```{r}
# Get proteins interaction
string_edgelist <- get_network_interaction(groot_df)

# Recomputing scores
string_edgelist <- combine_scores(string_edgelist, 
                                  evidences = c("ascore", "escore", "dscore"), 
                                  confLevel = 0.7)

colnames(string_edgelist) <- c("stringId_A", "stringId_B", "combined_score")

# Remove o species id
string_edgelist$stringId_A <- substring(string_edgelist$stringId_A, 6, 1000)
string_edgelist$stringId_B <- substring(string_edgelist$stringId_B, 6, 1000)

# How many edgelist proteins are absent in gene_ids? (should return 0)
setdiff(
  string_edgelist %$% c(stringId_A, stringId_B),
  map_ids %>% pull(stringId)
) 

head(string_edgelist)
```

To build the graph, in addition to the interactions between proteins, each node must be annotated with additional information that will be used in the analysis, such as:
- Protein name.
- The clade where it is rooted.
- The metabolic pathway in which it participates.

```{r}
## Create annotation table
nodelist <- data.frame(node = unique(c(string_edgelist$stringId_A, string_edgelist$stringId_B)))

merged_paths <- merge(nodelist, groot_df, by.x = "node", by.y = "protein_id")

pivotada <- sensorial_genes %>% 
  dplyr::select(gene_symbol, pathway_name) %>% 
  dplyr::mutate(n = 1) %>% 
  tidyr::pivot_wider(
    id_cols = gene_symbol,
    names_from = pathway_name,
    values_from = n,
    values_fn = list(n = length),
    values_fill = list(n = 0),
  )

source_statements <-
  colnames(pivotada)[2:length(pivotada)]

nodelist <-
  nodelist %>%
  left_join(merged_paths, by = c("node" = "node")) %>%
  left_join(map_ids, by = c("node" = "stringId")) %>%
  left_join(pivotada, by = c("queryItem" = "gene_symbol"))

head(nodelist)
```

In addition to the graph's structure, we can calculate metrics such as the number of connections (degree) for each node.

```{r}
# Network Metrics
connected_nodes <- rle(sort(c(string_edgelist[,1], string_edgelist[,2])))
connected_nodes <- data.frame(count=connected_nodes$lengths, node=connected_nodes$values)
connected_nodes <- left_join(nodelist, connected_nodes, by = c("node" = "node"))
connected_nodes <- dplyr::select(connected_nodes, queryItem, root, clade_name, count)

head(connected_nodes)
```

```{r}
#nodelist |> 
#  vroom::vroom_write(file = here("data/nodelist.csv"), delim = ",")
#string_edgelist |> 
#  vroom::vroom_write(file = here("data/string_edgelist.csv"), delim = ",")
#merged_paths |> 
#  vroom::vroom_write(file = here("data/merged_paths.csv"), delim = ",")
```
